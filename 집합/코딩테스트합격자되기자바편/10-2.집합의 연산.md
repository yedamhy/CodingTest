# 배열을 활용한 트리로 집합 표현하기

각 집합에는 대표 원소가 있어야 한다.

## 대표 원소란?

집합의 원소 중 집합을 대표하는 역할

⇒ 이후에는 루트 노드라고 부를 것.

## 배열로 집합을 표현하는 것이란?

하나의 배열로 상호배타적 관계를 가지는 집합을 모두 표현한다는 것을 의미

- 배열의 **index**는 **자신**을, 배열 **value**는 **부모노드**를 의미
- 루트 노드는 말 그대로 집합의 대표이미로 → 부모가 없고, 부모 노드가 자기 자신. 즉 루트 노드는 값 자체가 배열의 인덱스와 동일

## 집합 표현 정리하기


1. 각 잡합의 루트 노드는 1과 4 
    
    이를 disjoint_set 배열에 표현하면 `disjoint_set[1] = 1`, `disjoint_set[4] = 4`
    
    ⇒ 즉 인덱스와 값이 같다. 
    
2. `disjoint_set[3] = 2` , `disjoint_set[2] = 1` 을 해석해보면 
    - 집합 A의 원소 3의 부모는 2
    - 집합 A의 원소 2의 부모는 루트노드 1
3. 집합 A와 집합 B를 표현할 배열의 크기를 10으로 한다. 
    
    ⇒ 가장 큰 원소가 9이므로
    
4. 두 집합은 하나의 배열로 표현 가능하다.
5. 집합의 개수는 루트 노드의 개수를 보면 된다. 즉, 인덱스와 값이 같은 것이 몇개인지 확인!

### 집합을 배열로 구현하기

01단계

초기 각 노드는 자기 자신을 루트노드로 하고, 집합의 없는 인덱스의 값은 -1로 한다.

- 즉, 아직 1, 2, 3, 4, 5, 8, 9 는 누구와도 연결되지 않은 상태이므로 자기 자신을 값으로 가지고
- 나머지 인덱스 6과 7은 값을 -1로 가진다.

02단계

9의 루트 노드를 찾는 과정은 9 → 3 → 2 → 1순서

- 9 값을 3으로 변경
- 3 값을 2로 변경
- 2 값을 1로 변경

# 유니온-파인드 알고리즘

집합 알고리즘에 주로 쓰이는 연산은 **합치기(Union)**와 **탐색(Find)**

## 파인드 연산

파인드 연산은 특정 노드의 루트 노드가 무엇인지 확인할 때 사용 

예를 들어 A, B 두 노드가 있는데 이 노드의 루트 노드가 서로 같다면 같은 집합에 속한 것.

### 파인드 연산 과정

1. 현재 노드의 부모 노드 확인.
    
    if 부모 노드가 루트 노드 → 연산 종료
    
2. 1에서 찾기 연산이 종료되지 않으면 1 반복

### 파인드 연산의 연산 비용 문제 해결 : 경로 압축

경로 압축으로 해결해 볼 수 있다.

집합 형태를 유지하면서도 트리 높이를 줄이면 된다. 트리의 높이를 줄이므로 앞서 언급한 파인드 연산의 부모 노드를 거치는 과정을 줄일 수 있다.


## 합치기 연산

합치기 연산은 두 집합을 하나로 합치는 연산 ⇒ 즉 두 집합의 루트 노드를 같게 한다는 의미

### 합치기 연산 과정

1. 두 집합에서 찾기 연산을 통해 루트 노드를 찾는다.
2. 찾은 두 루트 노드의 값을 비교
3. 두 집합을 합친다. → 두 집합의 루트 노드를 같게 한다. 이때 루트 노드는 두 집합 중 어떤 루트 노드로 해도 상관 없다.

### 합치기 연산의 비용 문제 : 랭크

합치기 연산의 단점

: 트리의 깊이가 깊어질 수록 연산 비용이 커진다.

랭크란?

현재 노드를 기준으로 했을 때 가장 깊은 노드까지의 경로 길이 

- 랭크 기반으로 합치기 연산
    1. 두 노드의 루트 노드를 구한다.
    2. 1에서 구한 루트 노드의 랭크를 비교
        1. 랭크 값이 다르면 랭크 값이 큰 루트 노드를 기준으로 삼는다. 즉, 랭크가 더 큰 루트 노드를 랭크가 작은 루트 노드의 부모 노드로 바꾼다.
            
            이때 트리의 깊이는 더 깊어지지 않으므로 랭크의 값은 변하지 않음
            
        2. 랭크 값이 같으면 루트 노드를 아무거나 선택해서 바꾸고, 최종 루트 노드의 랭크에 1을 더한다.
