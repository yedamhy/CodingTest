트리 종류는 다양하지만 코딩 테스트에서는 이진 트리만 제대로 알고 있어도 충분하다.

# 이진 트리란?

이진 트리는 배열이나 포인터로 구현 가능

# 배열로 이진 트리 표현하기

배열은 선형 구조, 트리는 게층 자료구조

따라서 배열로 표현하려면 규칙  3가지가 필요 (루트 노드를 배열 인덱스 1번이라고 생각하고 작성)

- 루트 노드는 배열 인덱스 1번에 저장
- 왼쪽 자식 노드의 배열 인덱스는 부모 노드의 배열 인덱스 X 2
- 오른쪽 자식 노드의 배열 인덱스는 부모 노드의 배열 인덱스 X 2 + 1
        

| 인덱스 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 값 |  | 1 | 4 | 8 | 3 | 5 |  | 7 | 2 |  |  |  |  |  | 6 |

배열로 표현하면 빈 값이 꽤 많이 보임

⇒ 메모리가 낭비된다는 단점

BUT 이진 트리를 배열로 표현하는 방식은 구현 난이도가 쉬우므로, 메모리만 넉넉하면 구현 시간을 단축하는 용도로 Good

# 이진 트리 순회

## 전위 순회 (preorder)

현재 노드를 부모 노드로 생각했을 때

부모 노드 → 왼쪽 자식 노드 → 오른쪽 자식 노드

## 중위 순회 (inorder)

현재 노드를 부모 노드로 생각했을 때

왼쪽 자식 노드 → 부모 노드 → 오른쪽 자식 노드

## 후위 순회 (postorder)

현재 노드를 부모 노드로 생각했을 때

왼쪽 자식 노드 → 오른쪽 자식 노드 → 부모 노드

# 포인터로 이진 트리 표현하기

포인터로 트리를 표현하려면 노드부터 정의해야 함.


포인터로 표현한 트리는 배열과 달리 인덱스 연산을 하지 않는다. 즉 메모리 공간을 낭비하지 않음

BUT 실제 노드를 따라가도록 구현해야 하므로 구현 난이도는 배열로 표현한 트리에 비해 높음

# 인접 리스트로 이진 트리 표현하기

인접 리스트로 트리를 표현하려면 정점의 번호(수) 만큼 리스트를 만들어야 함.

리스트는 해당 정점에서 연결된 노드의 번호가 됨

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/850c748a-0632-4c9b-bb07-8ecd1ceb4703/f59346f8-ac70-41ca-9f57-552e5c2ecb81/image.png)

인접 리스트로 표현하면 자식 노드의 개수가 2개 이상일 경우에도 표현하기 좋음

또한 메모리 공간이 크게 낭비되지 않고, 어떤 정점에서 이동할 수 있는 다음 정점을 빠르게 탐색할 수도 있어 시간 복잡도 면에서도 상당히 이점이 많다.
