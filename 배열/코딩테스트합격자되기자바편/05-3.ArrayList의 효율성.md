# 배열 연산의 시간 복잡도

배열은 임의 접근이라는 방법으로 배열의 모든 위치에 있는 데이터에 단 번에 접근할 수 있다. 따라서 **데이터에 접근**하기 위한 **시간복잡도는 `O(1)`** 

하지만 배열에 데이터를 추가할 때는 **어디에 삽입**하냐는 추가 연산에 따라 시간복잡도가 달라진다

## 1. 맨 뒤에 삽입할 때

`int[] arr = {1, 2, 3}` 이 있다고 가정할 때 2를 추가한다고 가정해보자. `arr[3]`에 바로 접근할 수 있다. 또한, 데이터를 삽입해도 다른 데이터 위치에 영향을 주지 않는다. 따라서 **시간복잡도는 `O(1)`**

## 2. 맨 앞에 삽입할 때

맨 앞에 삽입하기 위해서는 기존 데이터들을 한 칸씩 뒤로 밀어야 함.

따라서 **시간복잡도는 `O(n)`**

## 3. 중간에 삽입할 때

`int[] arr = {1, 2, 3, 4, 5}` 에 3 뒤에 6을 삽입한다고 가정하면, 3 이후의 데이터를 뒤로 한 칸씩 밀어야 함.

즉, 현재 삽입한 데이터 뒤에 있는 데이터 개수만큼 미는 연산을 해야 함. 

**시간복잡도는 `O(n)`**

# 배열을 선택할 때 고려할 점

**1. 할당할 수 있는 메모리 크기를 확인하자**

배열로 표현하려는 데이터가 너무 많으면 런타임에서 배열 할당에 실패할 수 있다. ⇒ 보통 정수형 1차원 배열은 1000만개, 2차원 배열은 3000 x 3000  을 최대로 생각

**2. 중간에 데이터 삽입이 많은 지 확인하자**

시간초과… 유의
